ðŸ”§ Thread Pools (Executors Framework)

    âœ” What Thread Pools Solve
        * Reuse threads instead of creating new ones â†’ faster, efficient
        * Control concurrency level
        * Avoid excessive thread creation
        * Prevent thread-management errors
        * Essential for scalable apps


    âœ” Main Thread Pool Types
        * FixedThreadPool â€” stable number of threads, best for CPU-bound work
        * CachedThreadPool â€” grows on demand, best for short-lived I/O tasks
        * SingleThreadExecutor â€” guarantees sequential execution
        * ScheduledThreadPool â€” delayed and periodic task execution
        * WorkStealingPool â€” parallelism using ForkJoinPool, ideal for CPU-heavy tasks


    âœ” Strengths
        * Thread reuse â†’ low overhead
        * Task queueing â†’ smooth handling of load
        * Prevent unbounded thread creation (except CachedThreadPool)
        * Useful abstractions (Future, Callable, Scheduled tasks)


    âœ” Weaknesses / Pitfalls
        * CachedThreadPool can create unlimited threads â†’ OOM risk
        * Forgetting shutdown() keeps the JVM alive
        * Starvation when long tasks occupy small pools
        * Pools hide errors if not configured properly


    âœ” Real-world Use Cases
        * Web servers handling client requests
        * Email/SMS asynchronous sending
        * Batch processing jobs
        * Cron-like scheduling (ScheduledExecutorService)
        * Telemetry and monitoring tasks
        * Parallel data transformations


    âœ” Best Practices
        * Always call shutdown() or shutdownNow()
        * Choose pool size based on workload (CPU vs I/O)
        * Prefer Executors.newFixedThreadPool for controlled concurrency
        * Use ScheduledThreadPool for periodic jobs
        * For high parallelism, use WorkStealingPool or ForkJoinPool
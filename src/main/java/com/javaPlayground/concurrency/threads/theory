ðŸ”¥ 1. Thread Lifecycle

A thread has 5 main states:
    * New â€” created but not started
    * Runnable â€” ready or running
    * Blocked â€” waiting for monitor lock
    * Waiting / Timed Waiting â€” wait(), sleep(), or join()
    * Terminated â€” finished execution


ðŸ§¨ 2. Common Mistakes

    * Calling wait/notify outside synchronized â†’ IllegalMonitorStateException
    * Using if instead of while â†’ breaks on spurious wakeups
    * Using notify() instead of notifyAll() â†’ potential deadlocks in multi-consumer or multi-producer systems
    * Holding locks too long â†’ thread starvation
    * Forgetting that notify does NOT release lock â†’ confusion / unexpected delays


ðŸ§  3. Java Memory Model (JMM) (Mental Model)

      Concept                   What it Solves
    * volatile                  Visibility + Prevents Reordering
    * synchronized              Atomicity + Visibility + ordering
    * happens-before            Rules guaranteeing visibility=
    * atomic operations	        Indivisible operations
    * JMM                       Defines all allowed interactions between threads


ðŸ›‘ 4. Race Conditions & Correct Patterns

    * Race Condition: multiple threads access and modify shared data without proper synchronization â†’ inconsistent results
    * Fix with synchronized: ensures atomicity, ordering, and visibility
    * Fix with Atomic classes (AtomicInteger, AtomicBoolean): lock-free thread-safe updates
    * Confinement: avoid sharing mutable state between threads â†’ no synchronization needed
    * Immutability: immutable objects are inherently thread-safe
    * Safe Publication: ensure other threads see fully initialized objects
    * Correct double-checked locking requires volatile
    * Avoid deadlocks with consistent lock ordering and minimal lock scope


ðŸ§µ 5. Condition Queues, Memory Fences & False Sharing

+ Condition Queues Condition queues (Condition objects) are used with ReentrantLock to coordinate producers and consumers.
  They allow threads to wait until specific conditions become true.
    Key points:
        * await() puts a thread to sleep until signaled
        * signal() wakes a single waiting thread
        * signalAll() wakes all waiting threads
        * Used when synchronized + wait/notify is not enough
        * Enables multiple independent wait-sets per lock (unlike intrinsic locks)

    Example usage:
        * Producer waits for space â†’ notFull condition
        * Consumer waits for items â†’ notEmpty condition

+ Memory Fences (Barriers) Memory fences enforce ordering of memory operations.
  They prevent the CPU or compiler from rearranging reads/writes across the fence.

    In Java:
        * volatile write acts as a release fence
        * volatile read acts as an acquire fence
        * synchronized blocks act as full fences

    Guarantees:
        * All writes before a fence become visible to other threads
        * Prevents reorderings that break thread safety

+ False Sharing False sharing happens when two threads modify variables
  that lie close together in the same CPU cache line, causing unnecessary cache invalidations.

    Symptoms:
        * Performance degradation
        * High CPU usage
        * Unpredictable slowdowns in multi-threaded code

    Causes:
        * Adjacent fields accessed by different threads
        * Arrays where consecutive elements are updated by separate threads

    Fixes:
        * Padding fields (using @Contended)
        * Structuring data so different threads use different cache lines
        * Avoid tight coupling of independent counters or metrics
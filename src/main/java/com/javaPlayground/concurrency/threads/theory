ðŸ”¥ 1. Thread Lifecycle

A thread has 5 main states:
    * New â€” created but not started
    * Runnable â€” ready or running
    * Blocked â€” waiting for monitor lock
    * Waiting / Timed Waiting â€” wait(), sleep(), or join()
    * Terminated â€” finished execution


ðŸ§¨ 2. Common Mistakes

    * Calling wait/notify outside synchronized â†’ IllegalMonitorStateException
    * Using if instead of while â†’ breaks on spurious wakeups
    * Using notify() instead of notifyAll() â†’ potential deadlocks in multi-consumer or multi-producer systems
    * Holding locks too long â†’ thread starvation
    * Forgetting that notify does NOT release lock â†’ confusion / unexpected delays


ðŸ§  3. Java Memory Model (JMM) (Mental Model)

      Concept                   What it Solves
    * volatile                  Visibility + Prevents Reordering
    * synchronized              Atomicity + Visibility + ordering
    * happens-before            Rules guaranteeing visibility=
    * atomic operations	        Indivisible operations
    * JMM                       Defines all allowed interactions between threads


ðŸ›‘ 4. Race Conditions & Correct Patterns

    * Race Condition: multiple threads access and modify shared data without proper synchronization â†’ inconsistent results
    * Fix with synchronized: ensures atomicity, ordering, and visibility
    * Fix with Atomic classes (AtomicInteger, AtomicBoolean): lock-free thread-safe updates
    * Confinement: avoid sharing mutable state between threads â†’ no synchronization needed
    * Immutability: immutable objects are inherently thread-safe
    * Safe Publication: ensure other threads see fully initialized objects
    * Correct double-checked locking requires volatile
    * Avoid deadlocks with consistent lock ordering and minimal lock scope
üî• 1. Thread Lifecycle

    A thread has 5 main states:
        * New ‚Äî created but not started
        * Runnable ‚Äî ready or running
        * Blocked ‚Äî waiting for monitor lock
        * Waiting / Timed Waiting ‚Äî wait(), sleep(), or join()
        * Terminated ‚Äî finished execution


üß® 2. Common Mistakes

    * Calling wait/notify outside synchronized ‚Üí IllegalMonitorStateException
    * Using if instead of while ‚Üí breaks on spurious wakeups
    * Using notify() instead of notifyAll() ‚Üí potential deadlocks in multi-consumer or multi-producer systems
    * Holding locks too long ‚Üí thread starvation
    * Forgetting that notify does NOT release lock ‚Üí confusion / unexpected delays


üß† 3. Java Memory Model (JMM) (Mental Model)

      Concept                   What it Solves
    * volatile                  Visibility + Prevents Reordering
    * synchronized              Atomicity + Visibility + ordering
    * happens-before            Rules guaranteeing visibility=
    * atomic operations	        Indivisible operations
    * JMM                       Defines all allowed interactions between threads


üõë 4. Race Conditions & Correct Patterns

    * Race Condition: multiple threads access and modify shared data without proper synchronization ‚Üí inconsistent results
    * Fix with synchronized: ensures atomicity, ordering, and visibility
    * Fix with Atomic classes (AtomicInteger, AtomicBoolean): lock-free thread-safe updates
    * Confinement: avoid sharing mutable state between threads ‚Üí no synchronization needed
    * Immutability: immutable objects are inherently thread-safe
    * Safe Publication: ensure other threads see fully initialized objects
    * Correct double-checked locking requires volatile
    * Avoid deadlocks with consistent lock ordering and minimal lock scope


üßµ 5. Condition Queues, Memory Fences & False Sharing

    + Condition queues (Condition objects) are used with ReentrantLock to coordinate producers and consumers.
      They allow threads to wait until specific conditions become true.

        Key points:
            * await() puts a thread to sleep until signaled
            * signal() wakes a single waiting thread
            * signalAll() wakes all waiting threads
            * Used when synchronized + wait/notify is not enough
            * Enables multiple independent wait-sets per lock (unlike intrinsic locks)

        Example usage:
            * Producer waits for space ‚Üí notFull condition
            * Consumer waits for items ‚Üí notEmpty condition

    + Memory Fences (Barriers) enforce ordering of memory operations.
      They prevent the CPU or compiler from rearranging reads/writes across the fence.

        In Java:
            * volatile write acts as a release fence
            * volatile read acts as an acquire fence
            * synchronized blocks act as full fences

        Guarantees:
            * All writes before a fence become visible to other threads
            * Prevents reorderings that break thread safety

    + False sharing happens when two threads modify variables
      that lie close together in the same CPU cache line, causing unnecessary cache invalidations.

        Symptoms:
            * Performance degradation
            * High CPU usage
            * Unpredictable slowdowns in multi-threaded code

        Causes:
            * Adjacent fields accessed by different threads
            * Arrays where consecutive elements are updated by separate threads

        Fixes:
            * Padding fields (using @Contended)
            * Structuring data so different threads use different cache lines
            * Avoid tight coupling of independent counters or metrics

üîê 6. Advanced Locks ‚Äî ReadWriteLock vs StampedLock

    ReadWriteLock (ReentrantReadWriteLock)
        Strengths:
           * Multiple readers can proceed concurrently.
           * Writers get exclusive access.
           * Good for read-heavy workloads.

        Weakness:
           * Writers block all readers.
           * Reader starvation possible.

        Ideal Use Case:
           * Caches, configuration maps, product catalogs, reading 90%+, writing <10%.

    StampedLock
        Strengths:
           * Optimistic reads are extremely fast (no locking if no writer interferes).
           * Supports read lock, write lock, and optimistic read.
           * Great for highly read-dominated data structures.

        Weakness:
           * Not reentrant.
           * Requires manual validation of stamps.
           * Easy to misuse; deadlocks if not unlocking.

        Ideal Use Case:
           * Real-time analytics, geolocation services, monitoring dashboards, low-contention systems.

    Scientific Summary:
       * ReentrantReadWriteLock ‚Üí safer, simpler, predictable performance.
       * StampedLock ‚Üí fastest for optimistic-read-heavy workloads; unsafe if misused.
       * If readers dominate and data is mostly stable ‚Üí choose StampedLock.
       * If balance between simplicity and concurrency matters ‚Üí choose ReadWriteLock.


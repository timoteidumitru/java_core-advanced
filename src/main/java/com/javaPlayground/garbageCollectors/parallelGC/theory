Parallel GC ‚Äì Theory & Use Cases

Feature	                                                Description
üßµ Multi-threaded GC	                                Uses multiple threads to speed up both minor and major collections.
üßÆ Stop-the-world events	                            Still pauses application threads during collection, but finishes faster due to parallel work.
üöÄ Throughput-focused	                                Optimized to spend as much time as possible doing real work, not collecting garbage.
‚öôÔ∏è Simple tuning	                                    Requires minimal configuration; scalable with available CPU cores.
üß† Default in Java 8	                                Still widely used in server-side apps, ETL jobs, and backend processing.


Real-World Scenario	                                    Why Parallel GC Works Well
üß∞ Batch or ETL jobs	                                Throughput is more important than response time (latency).
üßÆ Scientific or numeric computations	                Long-running CPU-bound workloads with large data sets.
üåê Backend systems (non-interactive)	                Periodic GC pauses are fine if total work per second is maximized.
üßæ Report generators, log analyzers, CSV processors	    Data-intensive, single-user tools that can use multiple CPU cores.


Option	                                                Purpose
-XX:+UseParallelGC	                                    Enables the parallel collector (young + old gen).
-XX:ParallelGCThreads=N	                                Controls number of threads used for GC (default = number of CPU cores).
-Xms / -Xmx	                                            Set initial and max heap size.
-Xlog:gc*	                                            View GC activity (Java 9+).

Run Command: java -XX:+UseParallelGC -Xms512m -Xmx512m -Xlog:gc* com.javaPlayground.garbageCollectors.parallelGC.CsvReportAnalyzerParallel
